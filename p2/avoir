Pour obtenir la version du noyau :
k get nodes/mcordess -o json | jq '.status.nodeInfo.kernelVersion'

------------------------------------------------------------------------------------------

Tu dois configurer un cluster K3s en **mode serveur** avec 1 VM, faire tourner **3 applications web** (app1, app2, app3), et exposer ces applications **selon l'en-tête HTTP `Host`** utilisé dans la requête. Voici une solution étape par étape :

---

## 🎯 Objectif

* **1 VM K3s (nommée `tonloginS`)**
* **3 applis web accessibles selon l'en-tête `Host` :**

  * `app1.com` ⟶ affiche app1
  * `app2.com` ⟶ affiche app2 (avec 3 **réplicas**)
  * tout autre nom de domaine ou vide ⟶ affiche app3 (valeur par défaut)
* L'adresse IP de la VM est `192.168.56.110`

---

## 🧱 Étapes détaillées

---

### 1. 🖥️ Créer et configurer la VM

Assure-toi d’avoir une VM avec :

* Ubuntu 22.04 ou Debian (ou autre stable)
* IP fixe : `192.168.56.110`
* Nom de la VM : `tonloginS` (ex: `jessS`)

Modifie le réseau dans le `Vagrantfile` :

```ruby
config.vm.network "private_network", ip: "192.168.56.110"
```

---

### 2. 📦 Installer K3s (mode serveur)

Sur la VM :

```bash
curl -sfL https://get.k3s.io | sh -
```

Vérifie que tout fonctionne :

```bash
sudo kubectl get nodes
```

---

### 3. 🌐 Créer un Ingress Controller

Par défaut, K3s installe **Traefik** comme ingress controller. On l’utilisera ici.

Tu peux vérifier avec :

```bash
sudo kubectl get pods -A | grep traefik
```

---

### 4. 🛠️ Déployer les applications

Tu vas créer 3 **Deployment** + 3 **Services** + 1 **Ingress**

#### a. App1 (1 réplique)

```yaml
# app1.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app1
  template:
    metadata:
      labels:
        app: app1
    spec:
      containers:
      - name: app1
        image: nginx
        env:
        - name: APP
          value: app1
---
apiVersion: v1
kind: Service
metadata:
  name: app1
spec:
  selector:
    app: app1
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

#### b. App2 (3 réplicas)

```yaml
# app2.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app2
spec:
  replicas: 3
  selector:
    matchLabels:
      app: app2
  template:
    metadata:
      labels:
        app: app2
    spec:
      containers:
      - name: app2
        image: nginx
        env:
        - name: APP
          value: app2
---
apiVersion: v1
kind: Service
metadata:
  name: app2
spec:
  selector:
    app: app2
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

#### c. App3 (défaut)

```yaml
# app3.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app3
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app3
  template:
    metadata:
      labels:
        app: app3
    spec:
      containers:
      - name: app3
        image: nginx
        env:
        - name: APP
          value: app3
---
apiVersion: v1
kind: Service
metadata:
  name: app3
spec:
  selector:
    app: app3
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

---

### 5. 🌍 Créer une Ingress

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: apps-ingress
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  rules:
  - host: app1.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app1
            port:
              number: 80
  - host: app2.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app2
            port:
              number: 80
  - host: "*"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app3
            port:
              number: 80
```

---

### 6. 🚀 Appliquer les fichiers

```bash
kubectl apply -f app1.yaml
kubectl apply -f app2.yaml
kubectl apply -f app3.yaml
kubectl apply -f ingress.yaml
```

---

### 7. 🧪 Tester

Sur ta machine hôte, ajoute les entrées dans `/etc/hosts` :

```
192.168.56.110 app1.com
192.168.56.110 app2.com
```

Puis ouvre dans un navigateur :

* [http://app1.com](http://app1.com) ⟶ affiche app1
* [http://app2.com](http://app2.com) ⟶ affiche app2 (load balancé sur 3 pods)
* [http://192.168.56.110](http://192.168.56.110) ou un autre host ⟶ affiche app3

---

### ✅ Bonus : Personnaliser les pages (facultatif)

Pour voir la différence entre les applis, tu peux créer une image Docker personnalisée avec une page HTML différente ou utiliser une config `nginx.conf`.


--------------------------------------------------------------------------------


C'est quoi un ingress

Bonne question ! Un **Ingress** dans Kubernetes (et donc aussi dans **K3s**) est une **ressource qui gère l'accès externe** à tes applications **HTTP/HTTPS**, généralement via un **nom de domaine (host)** ou un **chemin URL**.

---

## 🔍 Définition simple

👉 **Ingress = une porte d’entrée HTTP dans ton cluster**

Il agit comme un **routeur** HTTP : il reçoit les requêtes venant de l'extérieur (navigateur, API...), puis les **redirige vers le bon service** (pod) dans ton cluster, selon des règles que tu définis.

---

## 📦 Exemples concrets

Imaginons que tu as 3 services dans ton cluster :

* `app1` → page d'accueil
* `app2` → API
* `app3` → admin

Tu veux que :

* `http://app1.com` aille vers app1
* `http://app2.com` aille vers app2
* `http://app3.com/admin` aille vers app3

Au lieu d’exposer chaque service avec un **NodePort** ou un **LoadBalancer**, tu crées **un seul point d’entrée** avec un **Ingress**, et tu le configures pour router chaque requête.

---

## 🧭 Fonctionnement schématique

```
Navigateur --> [Ingress Controller] --> Service --> Pods
               (Traefik/Nginx)
```

---

## 🛠️ Ingress vs Ingress Controller

Il y a 2 composants :

1. **Ingress** (objet YAML) → les règles
2. **Ingress Controller** → l'outil qui applique ces règles (ex: **Traefik** dans K3s)

💡 Dans K3s, **Traefik est déjà intégré par défaut** comme Ingress Controller.

---

## 📋 Exemple de règle Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mon-ingress
spec:
  rules:
  - host: app1.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app1
            port:
              number: 80
```

👉 Cette règle dit : “si une requête HTTP arrive avec le host `app1.com`, alors envoie-la au **service `app1`** sur le port 80”.

---

## ✅ En résumé

| Terme                  | Rôle                                                                       |
| ---------------------- | -------------------------------------------------------------------------- |
| **Ingress**            | Fichier YAML qui décrit les routes HTTP                                    |
| **Ingress Controller** | Application qui lit ces fichiers et fait le routage (Traefik, Nginx, etc.) |
| **Service**            | Fait le lien entre l'Ingress et les Pods                                   |
| **Pod**                | Contient ton application                                                   |

---

### 📦 Architecture du routage HTTP avec Ingress

```
                  🧑 Utilisateur (navigateur)
                            |
                            ▼
               🌍 Requête HTTP (ex: app1.com)
                            |
                            ▼
                 🚪 Ingress Controller (Traefik)
                            |
        ┌───────────────────┼────────────────────┐
        |                   |                    |
        ▼                   ▼                    ▼
    📦 Service app1     📦 Service app2       📦 Service app3
        |                   |                    |
        ▼                   ▼                    ▼
   🐳 Pod app1          🐳 Pod app2 x3       🐳 Pod app3
```

---

### 🧠 Ce qui se passe concrètement

1. **L’utilisateur** tape `http://app1.com` dans son navigateur.
2. La requête arrive à l’IP du cluster (ta VM `192.168.56.110`).
3. Le **Traefik Ingress Controller** reçoit la requête.
4. Il lit les règles définies dans l’**Ingress** :

   * Si `Host == app1.com` → route vers `service app1`
   * Si `Host == app2.com` → route vers `service app2` (3 réplicas)
   * Sinon → `service app3` (valeur par défaut)
5. Le **service** sélectionne un **pod** et transmet la requête.
6. Le **pod** répond (ex : `nginx`, `Hello from app2`, etc.)

---

### 📍 Ce qu’il te faut pour que ça marche :

* Les fichiers YAML `Deployment` + `Service` + `Ingress`
* Un **Ingress Controller** (Traefik est déjà là dans K3s)
* Ton `/etc/hosts` bien configuré avec :

```txt
192.168.56.110 app1.com
192.168.56.110 app2.com
```
